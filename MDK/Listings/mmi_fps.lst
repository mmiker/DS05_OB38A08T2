C51 COMPILER V9.59.0.0   MMI_FPS                                                           03/04/2021 14:31:22 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MMI_FPS
OBJECT MODULE PLACED IN .\Objects\mmi_fps.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE ..\mmi_src\mmi_fps.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\inc;..\mmi
                    -_inc;..\dqiot_inc) DEBUG OBJECTEXTEND PRINT(.\Listings\mmi_fps.lst) TABS(2) OBJECT(.\Objects\mmi_fps.obj)

line level    source

   1          #ifndef __MMI_FPC_C__
   2          #define __MMI_FPC_C__
   3          
   4          // #include "string.h"
   5          #include "mmi_fps.h"
   6          #include "mmi_feature.h"
   7          #include "dqiot_fp_sy.h"
   8          #include "OB38A08T2.h"
   9          #include "Timer.h"
  10          #include "Audio.h"
  11          // #include "dqiot_drv.h"
  12          
  13          #define FP_INT P0_3
  14          
  15          #ifdef __LOCK_FP_SUPPORT__
  16          unsigned char FP_oldStatus = 0;
  17          /*
  18          parameter: 
  19            current status machine
  20          return :
  21            none
  22          */
  23          //void mmi_dq_fp_set_fp_uart_handle_cb(fp_uart_handle_callback cb)
  24          //{
  25          
  26          //}
  27          
  28          /*
  29          parameter: 
  30            current status machine
  31          return :
  32            none
  33          */
  34          //void mmi_dq_fps_set_irq_handle_cb(fp_irq_handle_callback cb)
  35          //{
  36          //  cb = NULL;
  37          //}
  38          
  39          /*
  40          parameter: 
  41            current status machine
  42          return :
  43            none
  44          */
  45          unsigned char mmi_dq_fp_get_fp_mode(void)
  46          {
  47   1        return 1;
  48   1      }
  49          
  50          /*
  51          parameter: 
  52            current status machine
  53          return :
  54            none
C51 COMPILER V9.59.0.0   MMI_FPS                                                           03/04/2021 14:31:22 PAGE 2   

  55          */
  56          unsigned char mmi_dq_fp_get_image(void)
  57          {
  58   1        unsigned char retval = 0;
  59   1      
  60   1        retval = PS_GetImage();
  61   1        return retval;
  62   1      }
  63          
  64          /*
  65          parameter: 
  66            current status machine
  67          return :
  68            none
  69          */
  70          unsigned char mmi_dq_fp_gen_char(unsigned char id)
  71          {
  72   1        unsigned char retval = 0;
  73   1        unsigned char real_buf_id;
  74   1      
  75   1        if (id == 0)
  76   1          real_buf_id = CHAR_BUFFER1;
  77   1        else if (id == 1)
  78   1          real_buf_id = CHAR_BUFFER2;
  79   1        else if (id == 2)
  80   1          real_buf_id = CHAR_BUFFER3;
  81   1        else if (id == 3)
  82   1          real_buf_id = CHAR_BUFFER4;
  83   1      
  84   1        retval = PS_GenChar(real_buf_id); //生成特征
  85   1        return retval;
  86   1      }
  87          
  88          /*
  89          parameter: 
  90            current status machine
  91          return :
  92            none
  93          */
  94          unsigned char mmi_dq_fp_match(void)
  95          {
  96   1        unsigned char retval = 0;
  97   1      
  98   1        retval = PS_Match();
  99   1        return retval;
 100   1      }
 101          
 102          /*
 103          parameter: 
 104            current status machine
 105          return :
 106            none
 107          */
 108          unsigned char mmi_dq_fp_reg_module(void)
 109          {
 110   1        unsigned char retval = 0;
 111   1      
 112   1        retval = PS_RegModel();
 113   1        return retval;
 114   1      }
 115          
 116          /*
C51 COMPILER V9.59.0.0   MMI_FPS                                                           03/04/2021 14:31:22 PAGE 3   

 117          parameter: 
 118            current status machine
 119          return :
 120            none
 121          */
 122          unsigned char mmi_dq_fp_store_char(unsigned char id, unsigned short index)
 123          {
 124   1        unsigned char retval = 0;
 125   1        unsigned char real_buf_id;
 126   1      
 127   1        if (id == 0)
 128   1          real_buf_id = CHAR_BUFFER1;
 129   1        else if (id == 1)
 130   1          real_buf_id = CHAR_BUFFER2;
 131   1        else if (id == 2)
 132   1          real_buf_id = CHAR_BUFFER3;
 133   1        else if (id == 3)
 134   1          real_buf_id = CHAR_BUFFER4;
 135   1      
 136   1        retval = PS_StoreChar(real_buf_id, index); //储存模板
 137   1        return retval;
 138   1      }
 139          
 140          /*
 141          parameter: 
 142            current status machine
 143          return :
 144            none
 145          */
 146          unsigned char mmi_dq_fp_delete(unsigned short index)
 147          {
 148   1        unsigned char retval = 0;
 149   1      
 150   1        retval = PS_DeletChar(index, 1);
 151   1        return retval;
 152   1      }
 153          
 154          /*
 155          parameter: 
 156            current status machine
 157          return :
 158            none
 159          */
 160          unsigned char mmi_dq_fp_empty(void)
 161          {
 162   1        unsigned char retval = 0;
 163   1      
 164   1        retval = PS_Empty();
 165   1        return retval;
 166   1      }
 167          
 168          /*
 169          parameter: 
 170            current status machine
 171          return :
 172            none
 173          */
 174          unsigned char mmi_dq_fp_get_valid_templete(unsigned short *count)
 175          {
 176   1        unsigned char retval = 0;
 177   1      
 178   1        retval = PS_ValidTempleteNum(count);
C51 COMPILER V9.59.0.0   MMI_FPS                                                           03/04/2021 14:31:22 PAGE 4   

 179   1        return retval;
 180   1      }
 181          
 182          /*
 183          parameter: 
 184            current status machine
 185          return :
 186            none
 187          */
 188          unsigned char mmi_dq_fp_high_speed_search(unsigned char Buf_id, unsigned short *index)
 189          {
 190   1        unsigned char retval = 0;
 191   1        unsigned char real_buf_id;
 192   1      
 193   1        if (Buf_id == 0)
 194   1          real_buf_id = CHAR_BUFFER1;
 195   1        else if (Buf_id == 1)
 196   1          real_buf_id = CHAR_BUFFER2;
 197   1        else if (Buf_id == 2)
 198   1          real_buf_id = CHAR_BUFFER3;
 199   1        else if (Buf_id == 3)
 200   1          real_buf_id = CHAR_BUFFER4;
 201   1        retval = PS_HighSpeedSearch(real_buf_id, 0, 300, index);
 202   1        return retval;
 203   1      }
 204          
 205          /*
 206          parameter: 
 207            current status machine
 208          return :
 209            none
 210          */
 211          void mmi_dq_fp_light(FP_COLOR_E light_id)
 212          {
 213   1        FP_Light(light_id); //点灯
 214   1      }
 215          
 216          /*
 217          parameter: 
 218            current status machine
 219          return :
 220            none
 221          */
 222          FP_COLOR_E mmi_dq_fp_get_light(void)
 223          {
 224   1        FP_COLOR_E retval = 0;
 225   1        retval = FP_Get_Light();
 226   1        return retval;
 227   1      }
 228          
 229          /**
 230            * @brief  触摸判断
 231            * @param  none
 232            * @return none
 233            * @note   none
 234            * @see    none
 235            */
 236          unsigned char mmi_dq_fp_work(void)
 237          {
 238   1        if (FP_INT == 0)
 239   1        {
 240   2          if (FP_oldStatus == 0)
C51 COMPILER V9.59.0.0   MMI_FPS                                                           03/04/2021 14:31:22 PAGE 5   

 241   2          {
 242   3            FP_oldStatus = 1;
 243   3            return 1;
 244   3          }
 245   2        }
 246   1        else
 247   1          FP_oldStatus = 0;
 248   1        return 0;
 249   1      }
 250          
 251          unsigned char mmi_dq_fp_get_pin(void)
 252          {
 253   1        // return gpio_bit_get(GPIOF, GPIO_PIN_6);
 254   1        return FP_INT;
 255   1      }
 256          
 257          /**
 258            * @brief  录指纹
 259            * @param  ID 记录指纹个数
 260            * @return none
 261            * @note   none
 262            * @see    none
 263            */
 264          void Add_FR(u16 ID)
 265          {
 266   1        u8 i = 0, ensure, processnum = 0;
 267   1        u16 index = 0; //模板号
 268   1      
 269   1        while (1)
 270   1        {
 271   2          switch (processnum)
 272   2          {
 273   3          case 0:
 274   3            Audio_Play(AUD_ID_PRESS_FP); //请按手指
 275   3            processnum = 1;        //跳到第二步
 276   3          case 1:
 277   3            i++;
 278   3            ensure = PS_GetImage();
 279   3            if (ensure == 0x00)
 280   3            {
 281   4              ensure = PS_GenChar(CHAR_BUFFER1); //生成特征
 282   4              if (ensure == 0x00)
 283   4              {
 284   5                ensure = PS_HighSpeedSearch(CHAR_BUFFER1, 0, 300, &index);
 285   5                if (ensure == 0x00)
 286   5                {
 287   6                  FP_Light(FP_RED);
 288   6                  Audio_Play(AUD_ID_CHECK_FAIL_RETRY); //指纹已存在，请换个手指
 289   6                }
 290   5                else
 291   5                {
 292   6                  // "Fingerprint correct" //指纹正确
 293   6                  FP_Light(FP_GREEN);
 294   6                  i = 0;
 295   6                  processnum = 2; //跳到第二步
 296   6                }
 297   5              }
 298   4              else
 299   4              {
 300   5                FP_Light(FP_RED);
 301   5                Audio_Play(AUD_ID_CHECK_FAIL_RETRY); //指纹错误，请重试
 302   5              }
C51 COMPILER V9.59.0.0   MMI_FPS                                                           03/04/2021 14:31:22 PAGE 6   

 303   4            }
 304   3            else
 305   3              ; // is error
 306   3            break;
 307   3      
 308   3          case 2:
 309   3            Audio_Play(AUD_ID_PRESS_FP_AGAIN); //请再按一次
 310   3            processnum = 3;            //跳到第二步
 311   3      
 312   3          case 3:
 313   3            i++;
 314   3      
 315   3            ensure = PS_GetImage();
 316   3            if (ensure == 0x00)
 317   3            {
 318   4              ensure = PS_GenChar(CHAR_BUFFER2); //生成特征
 319   4              if (ensure == 0x00)
 320   4              {
 321   5                ensure = PS_HighSpeedSearch(CHAR_BUFFER2, 0, 300, &index);
 322   5                if (ensure == 0x00)
 323   5                {
 324   6                  FP_Light(FP_RED);
 325   6                  Audio_Play(AUD_ID_CHECK_FAIL_RETRY); //指纹已存在，请换个手指
 326   6                }
 327   5                else
 328   5                {
 329   6                  // "Fingerprint correct" //指纹正确
 330   6                  i = 0;
 331   6                  processnum = 4; //跳到第三步
 332   6                }
 333   5              }
 334   4              else
 335   4              {
 336   5                FP_Light(FP_RED);
 337   5                Audio_Play(AUD_ID_CHECK_FAIL_RETRY); //指纹错误，请重试
 338   5              }
 339   4            }
 340   3            else
 341   3              ; // is error
 342   3            break;
 343   3      
 344   3          case 4:
 345   3            // "Compare twice fingerprint" //对比两次指纹
 346   3            ensure = PS_Match();
 347   3            if (ensure == 0x00 || ensure == 0xff)
 348   3            {
 349   4              // "Twice fingerprint are same" //两次指纹是一样的
 350   4              processnum = 5; //跳到第四步
 351   4            }
 352   3            else
 353   3            {
 354   4              FP_Light(FP_RED);
 355   4              Audio_Play(AUD_ID_OPRATION_FAIL);  //两次输入的指纹不一致
 356   4              Audio_Play(AUD_ID_CHECK_FAIL_RETRY); //指纹错误，请重试
 357   4              i = 0;
 358   4              processnum = 0; //跳回第一步
 359   4            }
 360   3            // TIMER1_Delay(1000);
 361   3            break;
 362   3      
 363   3          case 5:
 364   3            // "Generate fingerprint template" //产生一个指纹模板
C51 COMPILER V9.59.0.0   MMI_FPS                                                           03/04/2021 14:31:22 PAGE 7   

 365   3            ensure = PS_RegModel();
 366   3            if (ensure == 0x00)
 367   3            {
 368   4              // "Generate fingerprint success" //生成指纹模板成功
 369   4              processnum = 6; //跳到第五步
 370   4            }
 371   3            else
 372   3            {
 373   4              FP_Light(FP_RED);
 374   4              Audio_Play(AUD_ID_ADD_FAIL);     //添加失败，请重试
 375   4              Audio_Play(AUD_ID_CHECK_FAIL_RETRY); //指纹错误，请重试
 376   4              processnum = 0;
 377   4              // is error
 378   4            }
 379   3            // TIMER1_Delay(1000);
 380   3            break;
 381   3      
 382   3          case 6:
 383   3            if (ID > 50)
 384   3            {
 385   4              // is error
 386   4              FP_Light(FP_RED);
 387   4              Audio_Play(AUD_ID_FP_FULL);      //指纹已满，请联系管理员
 388   4              Audio_Play(AUD_ID_CHECK_FAIL_RETRY); //指纹错误，请重试
 389   4              return;
 390   4            }
 391   3      
 392   3            ensure = PS_StoreChar(CHAR_BUFFER2, ID); //储存模板
 393   3            if (ensure == 0x00)
 394   3            {
 395   4              FP_Light(FP_GREEN);
 396   4              Audio_Play(AUD_ID_ADD_FP_SUCESS); //指纹添加成功
 397   4              ID++;               //成功id++，失败不变
 398   4              return;
 399   4            }
 400   3            else
 401   3            {
 402   4              FP_Light(FP_RED);
 403   4              Audio_Play(AUD_ID_ADD_FAIL);     //添加失败，请联系管理员
 404   4              Audio_Play(AUD_ID_CHECK_FAIL_RETRY); //指纹错误，请重试
 405   4              processnum = 0;
 406   4              // is error
 407   4            }
 408   3            break;
 409   3          }
 410   2          TIMER1_Delay(300);
 411   2          if (i == 5) //超过5次没有按手指则退出
 412   2          {
 413   3            FP_Light(FP_NONE_COLOR);
 414   3            TIMER1_Delay(300);
 415   3            FP_Light(FP_RED);
 416   3            // is quit
 417   3            return;
 418   3          }
 419   2        }
 420   1      }
 421          
 422          /**
 423            * @brief  删指纹
 424            * @param  TouchNum
 425            * 0: 清空
 426            * 1: 删除单个指纹
C51 COMPILER V9.59.0.0   MMI_FPS                                                           03/04/2021 14:31:22 PAGE 8   

 427            * @return 确认码
 428            * @note   none
 429            * @see    none
 430            */
 431          void Del_FR(u16 TouchNum)
 432          {
 433   1        u8 i = 0, ensure, processnum = 0;
 434   1        u16 index = 0; //模板号
 435   1      
 436   1        if (TouchNum == 0)
 437   1        {
 438   2          ensure = PS_Empty(); //清空指纹库
 439   2          if (ensure == 0)
 440   2            Audio_Play(AUD_ID_DEL_FP_SUCESS);
 441   2          else
 442   2            Audio_Play(AUD_ID_DEL_FAIL_RETRY);
 443   2          return;
 444   2        }
 445   1      
 446   1        if (TouchNum == 1)
 447   1        {
 448   2          while (1)
 449   2          {
 450   3            switch (processnum)
 451   3            {
 452   4      
 453   4            case 0:
 454   4              Audio_Play(AUD_ID_PRESS_FP); //请输入要删除的指纹
 455   4              processnum = 1;        //跳到第二步
 456   4      
 457   4            case 1:
 458   4              i++;
 459   4              ensure = PS_GetImage();
 460   4              if (ensure == 0x00)
 461   4              {
 462   5                ensure = PS_GenChar(CHAR_BUFFER1); //生成特征
 463   5                if (ensure == 0x00)
 464   5                {
 465   6                  ensure = PS_HighSpeedSearch(CHAR_BUFFER1, 0, 300, &index);
 466   6                  if (ensure == 0x00)
 467   6                  {
 468   7                    // "Fingerprint correct" //指纹正确
 469   7                    FP_Light(FP_GREEN);
 470   7                    i = 0;
 471   7                    processnum = 2; //跳到第二步
 472   7                  }
 473   6                  else
 474   6                  {
 475   7                    FP_Light(FP_RED);
 476   7                    Audio_Play(AUD_ID_CHECK_FAIL_RETRY); //指纹不存在，请重新输入
 477   7                  }
 478   6                }
 479   5                else
 480   5                {
 481   6                  FP_Light(FP_RED);
 482   6                  Audio_Play(AUD_ID_CHECK_FAIL_RETRY); //指纹错误，请重试
 483   6                }
 484   5              }
 485   4              else
 486   4                ; // is error
 487   4              break;
 488   4      
C51 COMPILER V9.59.0.0   MMI_FPS                                                           03/04/2021 14:31:22 PAGE 9   

 489   4            case 2:
 490   4              Audio_Play(AUD_ID_PRESS_FP_AGAIN); //请输入要删除的指纹
 491   4              processnum = 3;            //跳到第二步
 492   4      
 493   4            case 3:
 494   4              i++;
 495   4              ensure = PS_GetImage();
 496   4              if (ensure == 0x00)
 497   4              {
 498   5                ensure = PS_GenChar(CHAR_BUFFER2); //生成特征
 499   5                if (ensure == 0x00)
 500   5                {
 501   6                  ensure = PS_HighSpeedSearch(CHAR_BUFFER2, 0, 300, &index);
 502   6                  if (ensure == 0x00)
 503   6                  {
 504   7                    // "Fingerprint correct" //指纹正确
 505   7                    i = 0;
 506   7                    processnum = 4; //跳到第三步
 507   7                  }
 508   6                  else
 509   6                  {
 510   7                    FP_Light(FP_RED);
 511   7                    Audio_Play(AUD_ID_CHECK_FAIL_RETRY); //指纹不存在，请重新输入
 512   7                  }
 513   6                }
 514   5                else
 515   5                {
 516   6                  FP_Light(FP_RED);
 517   6                  Audio_Play(AUD_ID_CHECK_FAIL_RETRY); //指纹错误，请重试
 518   6                }
 519   5              }
 520   4              else
 521   4                ; // is error
 522   4              break;
 523   4      
 524   4            case 4:
 525   4              ensure = PS_DeletChar(index, 1); //删除单个指纹
 526   4              if (ensure == 0x00)
 527   4              {
 528   5                FP_Light(FP_GREEN);
 529   5                Audio_Play(AUD_ID_DEL_FP_SUCESS);
 530   5                return;
 531   5              }
 532   4              else
 533   4              {
 534   5                FP_Light(FP_RED);
 535   5                Audio_Play(AUD_ID_DEL_FAIL_RETRY);
 536   5              }
 537   4            }
 538   3            TIMER1_Delay(800);
 539   3            if (i == 5) //超过5次没有按手指则退出
 540   3            {
 541   4              FP_Light(FP_NONE_COLOR);
 542   4              TIMER1_Delay(300);
 543   4              FP_Light(FP_RED);
 544   4              TIMER1_Delay(300);
 545   4              // is quit
 546   4              return;
 547   4            }
 548   3          }
 549   2        }
 550   1      }
C51 COMPILER V9.59.0.0   MMI_FPS                                                           03/04/2021 14:31:22 PAGE 10  

 551          
 552          /**
 553            * @brief  刷指纹
 554            * @param  none
 555            * @return none
 556            * @note   none
 557            * @see    none
 558            */
 559          void press_FR(void)
 560          {
 561   1        u8 ensure;
 562   1        u16 index = 0;
 563   1        char *str;
 564   1        ensure = PS_GetImage();
 565   1        if (ensure == 0x00) //获取图像成功
 566   1        {
 567   2          ensure = PS_GenChar(CHAR_BUFFER1);
 568   2          if (ensure == 0x00) //生成特征成功
 569   2          {
 570   3            ensure = PS_HighSpeedSearch(CHAR_BUFFER1, 0, 300, &index);
 571   3            if (ensure == 0x00) //搜索成功
 572   3            {
 573   4              Audio_Play(AUD_ID_DOOR_OPEN);
 574   4              Audio_Play(AUD_ID_DOOR_CLOSE);
 575   4            }
 576   3            else
 577   3              Audio_Play(AUD_ID_CHECK_FAIL_RETRY);
 578   3          }
 579   2          else
 580   2          {
 581   3            FP_Light(FP_RED);
 582   3            Audio_Play(AUD_ID_CHECK_FAIL_RETRY); //指纹错误，请重试
 583   3          }
 584   2        }
 585   1      
 586   1        return;
 587   1      }
*** WARNING C280 IN LINE 563 OF ..\mmi_src\mmi_fps.c: 'str': unreferenced local variable
 588          
 589          #endif //__LOCK_FP_SUPPORT__
 590          
 591          #endif //__MMI_FPC_C__


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1205    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      5      27
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
