C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/04/2021 15:15:14 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE DQIOT_FP_SY
OBJECT MODULE PLACED IN .\Objects\dqiot_fp_sy.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE ..\src\dqiot_fp_sy.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\inc;..\mmi
                    -_inc) DEBUG OBJECTEXTEND PRINT(.\Listings\dqiot_fp_sy.lst) TABS(2) OBJECT(.\Objects\dqiot_fp_sy.obj)

line level    source

   1          
   2          //#if defined (__PREIPHERAL_FP_SY_SUPPORT__)
   3          //#include "string.h"
   4          #include "dqiot_fp_sy.h"
   5          #include "delay.h"
   6          #include "dqiot_drv.h"
   7          #include "OB38A08T2.h"
   8          #include "UART0.h"
   9          
  10          
  11          //unsigned long fp_pin_irq_mask;
  12          
  13          //fp_irq_handle_callback fp_callback_handle;
  14          //fp_uart_handle_callback fp_uart_handle = 0;
  15          //unsigned char fp_Mode = 0;
  16          //static unsigned char fp_temp_mode = 0;
  17          
  18          static unsigned char uart_rec_buff[20];
  19          
  20          //static FP_TYPE fp_flag = FP_NONE;
  21          static FP_COLOR_E Light_Color = FP_NONE_COLOR;
  22          //static unsigned char ps_start_flag = 0;
  23          
  24          // extern unsigned char uart_get_buf[];
  25          // extern unsigned char uart_getbuflen;
  26          extern unsigned char UART0_RXBUF[];
  27          extern unsigned char UART0_RXLEN;
  28          
  29          
  30          
  31          //unsigned short  ReceiveInfo( unsigned char *rec_data);
  32          //void AS608_log(void);
  33          
  34          //void fp_set_irq_handle(fp_irq_handle_callback cb)
  35          //{
  36          //  fp_callback_handle = cb;
  37          //}
  38          
  39          //void fp_set_uart_handle(fp_uart_handle_callback cb)
  40          //{
  41          //  fp_uart_handle = cb;
  42          //}
  43          
  44          
  45          ///FP_TYPE fp_get_type(void)
  46          //{
  47          //  return fp_flag;
  48          
  49          //}
  50          
  51          //--------------------------------------------------------------------------------
  52          
  53          //static unsigned char uart_len=0;
  54          //static unsigned short uart_maxlen = 0;
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/04/2021 15:15:14 PAGE 2   

  55          //static unsigned char uart_buff[25]={0};
  56          
  57          //static void UART_Callback(unsigned char send_data)
  58          //{
  59          //  send_data = 0;
  60          //}
  61          
  62          
  63          //unsigned char fp_GetModeState(void)
  64          //{
  65          //  return fp_Mode;
  66          //}
  67          
  68          //void fp_SetModeState(unsigned char s)
  69          //{
  70          //  fp_Mode = s;
  71            
  72          //  if(s == 0)  
  73          //    Light_Color = FP_NONE_COLOR;
  74          //}
  75          
  76          //static void PS_UART_Callback(unsigned char send_data)
  77          //{
  78          //  if(send_data == 0x55 )
  79          //  {
  80          //    ps_start_flag = 1;
  81          //  }
  82          //}
  83          
  84          //void FP_PowerOn(void)
  85          //{
  86          
  87          //}
  88          
  89          /**
  90            * @brief  AS608_USARTä¸²å£å‘æŒ‡çº¹æ¨¡å—ä¼ é€’æ•°æ® 
  91            * @param  data;ä¼ è¾“çš„æ•°æ®
  92            */
  93          void AS608_SendData(unsigned char send_data)
  94          {
  95   1        // uart_tx_byte(UART0, send_data);
  96   1        UART0_TX(send_data);
  97   1      }
  98          
  99          
 100          /**
 101            * @brief  AS608_USARTä¸²å£å‘æŒ‡çº¹æ¨¡å—å‘½ä»¤åŒ…å¤´æ ¼å¼ 
 102            * @param  æ— 
 103            */
 104          unsigned char AS608_PackHead(void)
 105          { 
 106   1      
 107   1        //unsigned char delay_times = 30;
 108   1        
 109   1        //while(ps_start_flag==0&&delay_times>0)
 110   1        //{
 111   1        //  delay_times--;
 112   1        //}
 113   1        //if(ps_start_flag == 0)
 114   1        //{
 115   1        //  return 1;
 116   1        //}
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/04/2021 15:15:14 PAGE 3   

 117   1        //else if(ps_start_flag == 1)
 118   1        //{
 119   1        //  uart_init_block();
 120   1        //  ps_start_flag = 2;
 121   1        //}
 122   1      
 123   1        /*åŒ…å¤´ SendHead*/
 124   1        AS608_SendData(0xEF);
 125   1        AS608_SendData(0x01);
 126   1      
 127   1        /*æŒ‡çº¹æ¨¡å—åœ°å€ SendAddr*/
 128   1        AS608_SendData(AS608_Addr >> 24);
 129   1        AS608_SendData(AS608_Addr >> 16);
 130   1        AS608_SendData(AS608_Addr >> 8);
 131   1        AS608_SendData(AS608_Addr);
 132   1      
 133   1        return 0;
 134   1      }
 135          
 136          unsigned char AS608_PackHead2(void)
 137          {
 138   1      
 139   1        /*åŒ…å¤´ SendHead*/
 140   1        AS608_SendData(0xEF);
 141   1        AS608_SendData(0x01); 
 142   1      
 143   1        /*æŒ‡çº¹æ¨¡å—åœ°å€*/
 144   1        AS608_SendData(AS608_Addr>>24);
 145   1        AS608_SendData(AS608_Addr>>16); 
 146   1        AS608_SendData(AS608_Addr>>8);
 147   1        AS608_SendData(AS608_Addr); 
 148   1      
 149   1        return 0;
 150   1      }
 151          
 152          /**
 153            * @brief  å‘é€åŒ…æ ‡è¯†
 154            * @param  flag:åŒ…æ ‡è¯†ä½
 155            * @retval æ— 
 156            */
 157           void SendFlag(unsigned char flag)
 158          {
 159   1        AS608_SendData(flag);
 160   1      }
 161          
 162          
 163          /**
 164            * @brief  å‘é€åŒ…é•¿åº¦
 165            * @param  length:åŒ…é•¿åº¦
 166            * @retval æ— 
 167            */
 168           void SendLength(unsigned short length)
 169          {
 170   1        AS608_SendData(length>>8);
 171   1        AS608_SendData(length);
 172   1      }
 173          
 174          
 175          /**
 176            * @brief  å‘é€æŒ‡ä»¤ç 
 177            * @param  cmd;æŒ‡ä»¤ç 
 178            * @retval æ— 
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/04/2021 15:15:14 PAGE 4   

 179            */
 180          void Sendcmd(unsigned char cmd)
 181          {
 182   1        AS608_SendData(cmd);
 183   1      }
 184          
 185          
 186          /**
 187            * @brief  å‘é€æ ¡éªŒå’Œ
 188            * @param  check:æ£€æŸ¥ä½
 189            * @retval æ— 
 190            */
 191           void SendCheck(unsigned short check)
 192          {
 193   1        AS608_SendData(check>>8);
 194   1        AS608_SendData(check);
 195   1      }
 196          
 197          /**
 198            * @brief  åˆ¤æ–­ä¸­æ–­æ¥æ”¶çš„æ•°ç»„æœ‰æ²¡æœ‰åº”ç­”åŒ…
 199            * @param  
 200            * waittimeä¸ºç­‰å¾…ä¸­æ–­æ¥æ”¶æ•°æ®çš„æ—¶é—´(å•ä½1ms)
 201            * lengthä¸ºåŒ…é•¿åº¦
 202            * @return æ•°æ®åŒ…ç¡®è®¤ç 
 203            * @note   1 failed
 204            * @see    none
 205            */
 206          static unsigned char JudgeStr(unsigned int waittime, unsigned char length)
 207          {
 208   1        unsigned char i = 0,j = 0;
 209   1        //u8 str[8];
 210   1        //str[0] = 0xEF;
 211   1        //str[1] = 0x01;
 212   1        //str[2] = AS608_Addr >> 24;
 213   1        //str[3] = AS608_Addr >> 16;
 214   1        //str[4] = AS608_Addr >> 8;
 215   1        //str[5] = AS608_Addr;
 216   1        //str[6] = 0x07;
 217   1      
 218   1        while (--waittime)
 219   1        {
 220   2          delay_ms(1);
 221   2      
 222   2          /* æ¥æ”¶åˆ°ä¸€æ¬¡æ•°æ® */
 223   2          if (UART0_RXLEN >= 9 + length)
 224   2          {
 225   3            /* å¯»æ‰¾0xEFä½ç½® */
 226   3            for (i = 0; i < UART0_RXLEN; i++)
 227   3            {
 228   4              if (UART0_RXBUF[i] == 0xEF)
 229   4                break;
 230   4            }
 231   3      
 232   3            /* åˆ¤æ–­æ˜¯å¦ä¸ºåº”ç­”åŒ… */
 233   3            if (UART0_RXBUF[i] == 0xEF && UART0_RXBUF[i + 1] == 0x01 && UART0_RXBUF[i + 6] == 0x07 && ((UART0_RXBUF
             -[i + 7] << 8) + UART0_RXBUF[i + 8]) == length)
 234   3            {
 235   4              for (i; i < UART0_RXLEN; i++)
 236   4              {
 237   5                uart_rec_buff[j] = UART0_RXBUF[i];
 238   5                j++;
 239   5              }
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/04/2021 15:15:14 PAGE 5   

 240   4              // getdata = uart_rec_buff[9]; //ç¡®è®¤ç 
 241   4      
 242   4              /* æ¸…ç©ºç¼“å­˜ */
 243   4              UART0_RXLEN = 0;
 244   4      
 245   4              return uart_rec_buff[9]; //ç¡®è®¤ç 
 246   4            }
 247   3          }
 248   2        }
 249   1      
 250   1        return 1;
 251   1      }
 252          
 253          #if 0
              /**
                * @brief  ä»ç¼“å†²åŒºè¯»å‡ºç¡®è®¤ç 
                * @param  *i:è¿”å›å€¼ï¼ˆç¡®è®¤ç ï¼‰
                * @retval æ— 
                */
              unsigned char  ReturnFlag( unsigned char *i)
              { 
                *i = ReceiveInfo(uart_rec_buff);
                return *i;
              }
              
              unsigned char  ReceiveInfo( unsigned char *rec_data)
              {
                unsigned char *temp_data;
                unsigned short rev_length = 0;
                unsigned char error = 0;
                unsigned char a = 9;
              
                memset(uart_rec_buff,0,sizeof(uart_rec_buff));
              
                do
                {
                  //error = nrf_drv_uart_rx(rec_data,1);
                  //if(error == NRF_ERROR_INTERNAL)
                  //  return 0xFF;
                  if(rec_data[0] == 0xEF)
                    break;
                  if(a==0)
                    return 0xFF;
                }while(a--);
                
              
                rev_length = (rec_data[7]<<8)+rec_data[8];
                temp_data = rec_data+9;
              
                if(rev_length!=0)
                  ;//nrf_drv_uart_rx(temp_data,rev_length);
                else
                  return 0xFF;
              
                AS608_log();
                return temp_data[0];
              }
              #endif
 298          
 299          unsigned char PS_GetEcho(void)
 300          {
 301   1        AS608_PackHead();
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/04/2021 15:15:14 PAGE 6   

 302   1        SendFlag(0x01);          
 303   1        SendLength(0x03);
 304   1        Sendcmd(0x53);              /*ç”Ÿæˆç‰¹å¾æŒ‡ä»¤*/   
 305   1        SendCheck(0x57);
 306   1      
 307   1        //sure=ReturnFlag(&p);
 308   1        return JudgeStr(1000, 0x03);
 309   1      }
 310          
 311          //å½•å…¥å›¾åƒ PS_GetImage
 312          //åŠŸèƒ½:æ¢æµ‹æ‰‹æŒ‡ï¼Œæ¢æµ‹åˆ°åå½•å…¥æŒ‡çº¹å›¾åƒå­˜äºImageBufferã€‚
 313          //æ¨¡å—è¿”å›ç¡®è®¤å­—
 314          unsigned char PS_GetImage(void)
 315          {
 316   1        /* æ¸…ç©ºç¼“å­˜ */
 317   1        UART0_RXLEN = 0;
 318   1      
 319   1        //delay_ms(300);
 320   1        if(AS608_PackHead()==1)
 321   1          return 0xFF;
 322   1        SendFlag(0x01);             /*å‘½ä»¤åŒ…æ ‡è¯†*/
 323   1        SendLength(0x03);
 324   1        Sendcmd(0x01);              /*å½•æŒ‡çº¹æŒ‡ä»¤*/
 325   1        SendCheck(0x01+0x03+0x01);
 326   1      
 327   1        //nrf_delay_ms(50);        /*ç­‰å¾…æŒ‡çº¹è¯†åˆ«æ¨¡å—å¤„ç†æ•°æ®*/
 328   1      
 329   1        // sure = ReturnFlag(&p);
 330   1        return JudgeStr(1000, 0x03);
 331   1      }
 332          
 333          
 334          //ç”Ÿæˆç‰¹å¾ PS_GenChar
 335          //åŠŸèƒ½:å°†ImageBufferä¸­çš„åŸå§‹å›¾åƒç”ŸæˆæŒ‡çº¹ç‰¹å¾æ–‡ä»¶å­˜äºCharBuffer1æˆ–CharBuffer2
 336          //å‚æ•°:BufferID --> charBuffer1:0x01  charBuffer1:0x02
 337          //æ¨¡å—è¿”å›ç¡®è®¤å­—
 338          unsigned char PS_GenChar(unsigned char BufferID)
 339          {
 340   1        if(AS608_PackHead()==1)
 341   1          return 0xFF;
 342   1        SendFlag(0x01);          
 343   1        SendLength(0x04);
 344   1        Sendcmd(0x02);              /*ç”Ÿæˆç‰¹å¾æŒ‡ä»¤*/   
 345   1        AS608_SendData(BufferID);
 346   1        SendCheck(0x01+0x04+0x02+BufferID);
 347   1        return JudgeStr(1000, 0x03);
 348   1      
 349   1      }
 350          
 351          //ç²¾ç¡®æ¯”å¯¹ä¸¤æšæŒ‡çº¹ç‰¹å¾ PS_Match
 352          //åŠŸèƒ½:ç²¾ç¡®æ¯”å¯¹CharBuffer1 ä¸CharBuffer2 ä¸­çš„ç‰¹å¾æ–‡ä»¶
 353          //æ¨¡å—è¿”å›ç¡®è®¤å­—
 354          unsigned char PS_Match(void)
 355          {
 356   1        if(AS608_PackHead()==1)
 357   1          return 0xFF;
 358   1        SendFlag(0x01);
 359   1        SendLength(0x03);
 360   1        Sendcmd(0x03);                /*ç²¾ç¡®æ¯”å¯¹æŒ‡ä»¤*/
 361   1        SendCheck(0x01+0x03+0x03);
 362   1        
 363   1        // sure = ReturnFlag(&p);
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/04/2021 15:15:14 PAGE 7   

 364   1        return JudgeStr(1000, 0x05);
 365   1      }
 366          //æœç´¢æŒ‡çº¹ PS_Search
 367          //åŠŸèƒ½:ä»¥CharBuffer1æˆ–CharBuffer2ä¸­çš„ç‰¹å¾æ–‡ä»¶æœç´¢æ•´ä¸ªæˆ–éƒ¨åˆ†æŒ‡çº¹åº“.è‹¥æœç´¢åˆ°ï¼Œåˆ™è¿
             -”å›é¡µç ã€‚
 368          //å‚æ•°:  BufferID @ref CharBuffer1  CharBuffer2
 369          //è¯´æ˜:  æ¨¡å—è¿”å›ç¡®è®¤å­—ï¼Œé¡µç ï¼ˆç›¸é…æŒ‡çº¹æ¨¡æ¿ï¼‰
 370          unsigned char PS_Search(unsigned char BufferID,unsigned short StartPage,unsigned short PageNum,unsigned sh
             -ort *p)
 371          {
 372   1        
 373   1        unsigned char  sure;
 374   1        if(AS608_PackHead()==1)
 375   1          return 0xFF;
 376   1        SendFlag(0x01); //å‘½ä»¤åŒ…æ ‡è¯†
 377   1        SendLength(0x08);
 378   1        Sendcmd(0x04);
 379   1        AS608_SendData(BufferID);
 380   1        AS608_SendData(StartPage>>8);
 381   1        AS608_SendData(StartPage);
 382   1        AS608_SendData(PageNum>>8);
 383   1        AS608_SendData(PageNum);
 384   1        SendCheck(0x01+0x08+0x04+BufferID+(StartPage>>8)+(unsigned char)StartPage+(PageNum>>8)+(unsigned char)Pag
             -eNum);
 385   1        sure = JudgeStr(1000, 0x07);
 386   1        *p=(uart_rec_buff[10]<<8)+uart_rec_buff[11];
 387   1        return sure;  
 388   1      }
 389          
 390          //åˆå¹¶ç‰¹å¾ï¼ˆç”Ÿæˆæ¨¡æ¿ï¼‰PS_RegModel
 391          //åŠŸèƒ½:å°†CharBuffer1ä¸CharBuffer2ä¸­çš„ç‰¹å¾æ–‡ä»¶åˆå¹¶ç”Ÿæˆ æ¨¡æ¿,ç»“æœå­˜äºCharBuffer1ä¸CharB
             -uffer2
 392          //è¯´æ˜:  æ¨¡å—è¿”å›ç¡®è®¤å­—
 393          unsigned char PS_RegModel(void)
 394          {   
 395   1        if(AS608_PackHead()==1)
 396   1          return 0xFF;
 397   1        SendFlag(0x01);
 398   1        SendLength(0x03);
 399   1        Sendcmd(0x05);                /*åˆå¹¶ç‰¹å¾æŒ‡ä»¤*/
 400   1        SendCheck(0x01+0x03+0x05);
 401   1      
 402   1        // sure = ReturnFlag(&p);
 403   1        return JudgeStr(1000, 0x03);
 404   1      }
 405          
 406          //å‚¨å­˜æ¨¡æ¿ PS_StoreChar
 407          //åŠŸèƒ½:å°† CharBuffer1 æˆ– CharBuffer2 ä¸­çš„æ¨¡æ¿æ–‡ä»¶å­˜åˆ° PageID å·flashæ•°æ®åº“ä½ç½®ã€‚
 408          //å‚æ•°:  BufferID @ref charBuffer1:0x01 charBuffer1:0x02
 409          //       PageIDï¼ˆæŒ‡çº¹åº“ä½ç½®å·ï¼‰
 410          //è¯´æ˜:  æ¨¡å—è¿”å›ç¡®è®¤å­—
 411          unsigned char PS_StoreChar(unsigned char BufferID, unsigned short PageID)
 412          {
 413   1        if (AS608_PackHead() == 1)
 414   1          return 0xFF;
 415   1        SendFlag(0x01);
 416   1        SendLength(0x06);
 417   1        Sendcmd(0x06);                /*å­˜å‚¨æ¨¡æ¿æŒ‡ä»¤*/
 418   1        AS608_SendData(BufferID);
 419   1          AS608_SendData(PageID>>8);
 420   1        AS608_SendData(PageID);
 421   1        SendCheck(0x01+0x06+0x06+BufferID+(PageID>>8)+(unsigned char)PageID);
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/04/2021 15:15:14 PAGE 8   

 422   1      
 423   1        return JudgeStr(1000, 0x03);
 424   1      }
 425          
 426          //åˆ é™¤æ¨¡æ¿ PS_DeletChar
 427          //åŠŸèƒ½:  åˆ é™¤flashæ•°æ®åº“ä¸­æŒ‡å®šIDå·å¼€å§‹çš„Nä¸ªæŒ‡çº¹æ¨¡æ¿
 428          //å‚æ•°:  PageID(æŒ‡çº¹åº“æ¨¡æ¿å·)ï¼ŒNåˆ é™¤çš„æ¨¡æ¿ä¸ªæ•°ã€‚
 429          //è¯´æ˜:  æ¨¡å—è¿”å›ç¡®è®¤å­—
 430          unsigned char PS_DeletChar(unsigned short PageID, unsigned short N)
 431          {
 432   1        if (AS608_PackHead() == 1)
 433   1          return 0xFF;
 434   1        SendFlag(0x01);//å‘½ä»¤åŒ…æ ‡è¯†
 435   1        SendLength(0x07);
 436   1        Sendcmd(0x0C);                /*åˆ é™¤æŒ‡å®šæŒ‡çº¹æ¨¡æ¿æŒ‡ä»¤*/
 437   1        AS608_SendData(PageID>>8);
 438   1          AS608_SendData(PageID);
 439   1        AS608_SendData(N>>8);
 440   1        AS608_SendData(N);
 441   1        SendCheck(0x01+0x07+0x0C+(PageID>>8)+(unsigned char)PageID+(N>>8)+(unsigned char)N);
 442   1        
 443   1        //AS608_DELAY_MS(400);
 444   1        
 445   1        // sure = ReturnFlag(&p);
 446   1        return JudgeStr(1000, 0x03);  
 447   1      }
 448          
 449          //é«˜é€Ÿæœç´¢PS_HighSpeedSearch
 450          //åŠŸèƒ½ï¼šä»¥ CharBuffer1æˆ–CharBuffer2ä¸­çš„ç‰¹å¾æ–‡ä»¶é«˜é€Ÿæœç´¢æ•´ä¸ªæˆ–éƒ¨åˆ†æŒ‡çº¹åº“ã€‚
 451          //      è‹¥æœç´¢åˆ°ï¼Œåˆ™è¿”å›é¡µç ,è¯¥æŒ‡ä»¤å¯¹äºçš„ç¡®å­˜åœ¨äºæŒ‡çº¹åº“ä¸­ ï¼Œä¸”ç™»å½•æ—¶è´¨é‡
 452          //      å¾ˆå¥½çš„æŒ‡çº¹ï¼Œä¼šå¾ˆå¿«ç»™å‡ºæœç´¢ç»“æœã€‚
 453          //å‚æ•°:  BufferIDï¼Œ StartPage(èµ·å§‹é¡µ)ï¼ŒPageNumï¼ˆé¡µæ•°ï¼‰
 454          //è¯´æ˜:  æ¨¡å—è¿”å›ç¡®è®¤å­—+é¡µç ï¼ˆç›¸é…æŒ‡çº¹æ¨¡æ¿ï¼‰
 455          unsigned char PS_HighSpeedSearch(unsigned char BufferID, unsigned short StartPage, unsigned short PageNum,
             - unsigned short *p)
 456          {
 457   1          unsigned char ensure;
 458   1      
 459   1        if(AS608_PackHead()==1)
 460   1          return 0xFF;
 461   1        SendFlag(0x01);
 462   1        SendLength(0x08);
 463   1        Sendcmd(0x1b);                 /*é«˜é€Ÿæœç´¢æŒ‡çº¹åº“æŒ‡ä»¤*/
 464   1        AS608_SendData(BufferID);
 465   1        AS608_SendData(StartPage>>8);
 466   1        AS608_SendData(StartPage);
 467   1        AS608_SendData(PageNum>>8);
 468   1        AS608_SendData(PageNum);
 469   1        SendCheck(0x01+0x08+0x1b+BufferID+(StartPage>>8)+(unsigned char)StartPage+(PageNum>>8)+(unsigned char)Pag
             -eNum);
 470   1      
 471   1        // ensure = ReturnFlag(&rc);
 472   1        ensure = JudgeStr(1000, 0x07);
 473   1      
 474   1        *p=(uart_rec_buff[10]<<8)+uart_rec_buff[11];
 475   1      
 476   1        return ensure;
 477   1      }
 478          
 479          //æ¸…ç©ºæŒ‡çº¹åº“ PS_Empty
 480          //åŠŸèƒ½:  åˆ é™¤flashæ•°æ®åº“ä¸­æ‰€æœ‰æŒ‡çº¹æ¨¡æ¿
 481          //å‚æ•°:  æ— 
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/04/2021 15:15:14 PAGE 9   

 482          //è¯´æ˜:  æ¨¡å—è¿”å›ç¡®è®¤å­—
 483          unsigned char PS_Empty(void)
 484          {
 485   1        if(AS608_PackHead()==1)
 486   1          return 0xFF;
 487   1        SendFlag(0x01);//å‘½ä»¤åŒ…æ ‡è¯†
 488   1        SendLength(0x03);
 489   1        Sendcmd(0x0D);
 490   1        SendCheck(0x01+0x03+0x0D);
 491   1        
 492   1        // sure = ReturnFlag(&p);
 493   1        return JudgeStr(1000, 0x03);
 494   1      }
 495          
 496          #if 0
              /**
                * @brief  æ£€æŸ¥STM32ä¸æŒ‡çº¹æ¨¡å—çš„é€šä¿¡è¿æ¥
                * @param  PS_AddræŒ‡çº¹æ¨¡å—åœ°å€
                * @retval è¿”å›å€¼0é€šè®¯æˆåŠŸ;1è¡¨ç¤ºé€šè®¯ä¸æˆåŠŸ
                */
              unsigned char PS_Connect(unsigned long *PS_Addr)
              {
                PS_Addr = 0;
                if(AS608_PackHead()==1)
                  return 0xFF;
                AS608_SendData(0X01);
                AS608_SendData(0X00);
                AS608_SendData(0X00);
                return 1;   
              }
              
              //å†™ç³»ç»Ÿå¯„å­˜å™¨ PS_WriteReg
              //åŠŸèƒ½:  å†™æ¨¡å—å¯„å­˜å™¨
              //å‚æ•°:  å¯„å­˜å™¨åºå·RegNum:4\5\6
              //è¯´æ˜:  æ¨¡å—è¿”å›ç¡®è®¤å­—
              unsigned char PS_WriteReg(unsigned char RegNum, unsigned char DATA)
              {
                unsigned short temp;
                unsigned short sure,p=0;
              
                if(AS608_PackHead()==1)
                  return 0xFF;
                SendFlag(0x01);//é›æˆ’æŠ¤é–å‘®çˆ£ç’‡
                SendLength(0x05);
                Sendcmd(0x0E);
                AS608_SendData(RegNum);
                AS608_SendData(DATA);
                temp = RegNum+DATA+0x01+0x05+0x0E;
                SendCheck(temp);
                sure=ReturnFlag(&p);
                return sure;
              }
              //è¯»ç³»ç»ŸåŸºæœ¬å‚æ•° PS_ReadSysPara
              //åŠŸèƒ½:  è¯»å–æ¨¡å—çš„åŸºæœ¬å‚æ•°ï¼ˆæ³¢ç‰¹ç‡ï¼ŒåŒ…å¤§å°ç­‰)
              //å‚æ•°:  æ— 
              //è¯´æ˜:  æ¨¡å—è¿”å›ç¡®è®¤å­— + åŸºæœ¬å‚æ•°ï¼ˆ16bytesï¼‰
              unsigned char PS_ReadSysPara(void)
              {
                unsigned short temp;
                unsigned char  ensure;
                unsigned char  *send_data;
                unsigned short p=0;
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/04/2021 15:15:14 PAGE 10  

                
                if(AS608_PackHead()==1)
                  return 0xFF;
                SendFlag(0x01);//é›æˆ’æŠ¤é–å‘®çˆ£ç’‡
                SendLength(0x03);
                Sendcmd(0x0F);
                temp = 0x01+0x03+0x0F;
                SendCheck(temp);
                ensure=ReturnFlag(&p);
                if(send_data)
                {
              
                }   
                else
                  ensure=0xff;
                if(ensure==0x00)
                {
              
                }
                return ensure;
              }
              //è®¾ç½®æ¨¡å—åœ°å€ PS_SetAddr
              //åŠŸèƒ½:  è®¾ç½®æ¨¡å—åœ°å€
              //å‚æ•°:  PS_addr
              //è¯´æ˜:  æ¨¡å—è¿”å›ç¡®è®¤å­—
              unsigned char PS_SetAddr(unsigned long PS_addr)
              {
                unsigned short temp;
                unsigned char  ensure;
              
                if(AS608_PackHead()==1)
                  return 0xFF;
                SendFlag(0x01);//å‘½ä»¤åŒ…æ ‡è¯†
                SendLength(0x07);
                Sendcmd(0x15);
                AS608_SendData(PS_addr>>24);
                AS608_SendData(PS_addr>>16);
                AS608_SendData(PS_addr>>8);
                AS608_SendData(PS_addr);
                temp = 0x01+0x07+0x15
                +(unsigned char)(PS_addr>>24)+(unsigned char)(PS_addr>>16)
                +(unsigned char)(PS_addr>>8) +(unsigned char)PS_addr;       
                SendCheck(temp);
              
                return ensure;
              }
              //åŠŸèƒ½ï¼š æ¨¡å—å†…éƒ¨ä¸ºç”¨æˆ·å¼€è¾Ÿäº†256bytesçš„FLASHç©ºé—´ç”¨äºå­˜ç”¨æˆ·è®°äº‹æœ¬,
              //  è¯¥è®°äº‹æœ¬é€»è¾‘ä¸Šè¢«åˆ†æˆ 16 ä¸ªé¡µã€‚
              //å‚æ•°:  NotePageNum(0~15),Byte32(è¦å†™å…¥å†…å®¹ï¼Œ32ä¸ªå­—èŠ‚)
              //è¯´æ˜:  æ¨¡å—è¿”å›ç¡®è®¤å­—
              unsigned char PS_WriteNotepad(unsigned char NotePageNum,unsigned char *Byte32)
              {
                unsigned short temp;
                unsigned char  ensure,i;
                
                *Byte32 = 0;
                
                if(AS608_PackHead()==1)
                  return 0xFF;
                SendFlag(0x01); //å‘½ä»¤åŒ…æ ‡è¯†
                SendLength(36);
                Sendcmd(0x18);
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/04/2021 15:15:14 PAGE 11  

                AS608_SendData(NotePageNum);
                for(i=0;i<32;i++)
                {
                  AS608_SendData(Byte32[i]);
                  temp += Byte32[i];
                }
                temp =0x01+36+0x18+NotePageNum+temp;
                SendCheck(temp);
              
                return ensure;
              }
              //è¯»è®°äº‹PS_ReadNotepad
              //åŠŸèƒ½ï¼š  è¯»å–FLASHç”¨æˆ·åŒºçš„128bytesæ•°æ®
              //å‚æ•°:  NotePageNum(0~15)
              //è¯´æ˜:  æ¨¡å—è¿”å›ç¡®è®¤å­—+ç”¨æˆ·ä¿¡æ¯
              unsigned char PS_ReadNotepad(unsigned char NotePageNum,unsigned char *Byte32)
              {
                unsigned short temp;
                unsigned char  ensure;
                
                *Byte32 = 0;
                
                if(AS608_PackHead()==1)
                  return 0xFF;
                SendFlag(0x01);//å‘½ä»¤åŒ…æ ‡è¯†
                SendLength(0x04);
                Sendcmd(0x19);
                AS608_SendData(NotePageNum);
                temp = 0x01+0x04+0x19+NotePageNum;
                SendCheck(temp);
              
                return ensure;
              }
              #endif
 640          
 641          //è¯»æœ‰æ•ˆæ¨¡æ¿ä¸ªæ•° PS_ValidTempleteNum
 642          //åŠŸèƒ½ï¼šè¯»æœ‰æ•ˆæ¨¡æ¿ä¸ªæ•°
 643          //å‚æ•°: æ— 
 644          //è¯´æ˜: æ¨¡å—è¿”å›ç¡®è®¤å­—+æœ‰æ•ˆæ¨¡æ¿ä¸ªæ•°ValidN
 645          unsigned char PS_ValidTempleteNum(unsigned short *ValidN)
 646          {
 647   1        unsigned char  ensure;
 648   1        
 649   1        if(AS608_PackHead()==1)
 650   1          return 0xFF;
 651   1        SendFlag(0x01); //å‘½ä»¤åŒ…æ ‡è¯†
 652   1        SendLength(0x03);
 653   1        Sendcmd(0x1d);
 654   1        SendCheck(0x01+0x03+0x1d);
 655   1      
 656   1        // ensure = ReturnFlag(&p);
 657   1        ensure = JudgeStr(1000, 0x05);
 658   1      
 659   1        *ValidN=(uart_rec_buff[10]<<8)+uart_rec_buff[11];
 660   1      
 661   1        return ensure;
 662   1      }
 663          
 664          unsigned char PS_AutoEnRoll(unsigned short id, unsigned char num, unsigned short param)
 665          {
 666   1        if(AS608_PackHead()==1)
 667   1          return 0xFF;
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/04/2021 15:15:14 PAGE 12  

 668   1        SendFlag(0x01); //å‘½ä»¤åŒ…æ ‡è¯†
 669   1        SendLength(0x08);
 670   1        Sendcmd(0x31);
 671   1        AS608_SendData(id>>8);
 672   1        AS608_SendData(id &0xFF);
 673   1        AS608_SendData(num);
 674   1        AS608_SendData(param>>8);
 675   1        AS608_SendData(param&0xFF);
 676   1        SendCheck(0x01 + 0x08 + 0x31 + (id>>8) + (id&0xFF) + num + (param>>8) + (param&0xFF));
 677   1      
 678   1        return 0;
 679   1      }
 680          
 681          //è‡ªåŠ¨éªŒè¯æŒ‡çº¹ PS_AutoIdentify
 682          //åŠŸèƒ½ï¼š
 683          //1.è‡ªåŠ¨é‡‡é›†æŒ‡çº¹ï¼Œåœ¨æŒ‡çº¹åº“ä¸­æœç´¢ç›®æ ‡æ¨¡æ¿å¹¶è¿”å›æœç´¢ç»“æœã€‚
 684          //2.å¦‚æœç›®æ ‡æ¨¡æ¿åŒå½“å‰é‡‡é›†çš„æŒ‡çº¹æ¯”å¯¹å¾—åˆ†å¤§äºæœ€é«˜é˜€å€¼ï¼Œå¹¶ä¸”ç›®æ ‡æ¨¡æ¿ä¸ºä¸å®Œ
             -æ•´ç‰¹å¾åˆ™ä»¥é‡‡é›†çš„ç‰¹å¾æ›´æ–°ç›®æ ‡æ¨¡æ¿çš„ç©ºç™½åŒºåŸŸã€‚
 685          //å‚æ•°: æ— 
 686          //è¯´æ˜: æ¨¡å—è¿”å›ç¡®è®¤å­—+é¡µç ï¼ˆç›¸é…æŒ‡çº¹æ¨¡æ¿ï¼‰
 687          unsigned char PS_AutoIdentify(unsigned short id, unsigned char level, unsigned short param)
 688          {
 689   1        if(AS608_PackHead()==1)
 690   1          return 0xFF;
 691   1        SendFlag(0x01); //å‘½ä»¤åŒ…æ ‡è¯†
 692   1        SendLength(0x08);
 693   1        Sendcmd(0x32);
 694   1        AS608_SendData(level);
 695   1        AS608_SendData(id>>8);
 696   1        AS608_SendData(id &0xFF);
 697   1        AS608_SendData(param>>8);
 698   1        AS608_SendData(param&0xFF);
 699   1        SendCheck(0x01 + 0x08 + 0x32 + (id>>8) + (id&0xFF) + level + (param>>8) + (param&0xFF));
 700   1      
 701   1        return 0;
 702   1      
 703   1      }
 704          
 705          //ä¸AS608æ¡æ‰‹ PS_HandShake
 706          //å‚æ•°: PS_Addråœ°å€æŒ‡é’ˆ
 707          //è¯´æ˜: æ¨¡å—è¿”æ–°åœ°å€ï¼ˆæ­£ç¡®åœ°å€ï¼‰
 708          unsigned char PS_HandShake(unsigned long *PS_Addr)
 709          {
 710   1        *PS_Addr = 0;
 711   1      
 712   1        if (AS608_PackHead() == 1)
 713   1          return 0xFF;
 714   1        SendFlag(0x01);
 715   1        SendLength(0x03);
 716   1        Sendcmd(0x53);
 717   1        SendCheck(0x57);
 718   1        
 719   1        return JudgeStr(1000, 0x03);
 720   1      }
 721          
 722          unsigned char PS_Reset(void)
 723          {
 724   1          return 0;
 725   1      }
 726          
 727          
 728          unsigned char PS_Sleep(void)
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/04/2021 15:15:14 PAGE 13  

 729          { 
 730   1        if(AS608_PackHead()==1)
 731   1          return 0xFF;
 732   1        SendFlag(0x01); //å‘½ä»¤åŒ…æ ‡è¯†
 733   1        SendLength(0x03);
 734   1        Sendcmd(0x60);
 735   1        SendCheck(0x01+0x03+0x60);
 736   1        return 0;
 737   1      }
 738          
 739          //void AS608_log(void)
 740          //{
 741          //  unsigned char i =0;
 742          ////  NRF_LOG_PRINTF_DEBUG("receive :");
 743          //  for(i=0;i<25;i++)
 744          //  {
 745          //    NRF_LOG_PRINTF_DEBUG("%2x ",as608_rec_buff[i]);
 746          //  }
 747          //  NRF_LOG_PRINTF_DEBUG("\n");
 748          //}
 749          
 750          void FP_Light(FP_COLOR_E light_id)
 751          {
 752   1      //  if(fp_flag == FP_LT5X)
 753   1      //  {
 754   1      //#ifdef __FP_LT5X_LIGHT_SUPPORT__
 755   1          unsigned short temp;
 756   1      
 757   1          unsigned char  sure = 0;//,p=0;
 758   1          if(light_id == Light_Color)
 759   1            return;
 760   1      
 761   1          if(AS608_PackHead()==1)
 762   1            return;
 763   1          SendFlag(0x01);          
 764   1          SendLength(0x07);
 765   1          Sendcmd(0x41); 
 766   1          switch(light_id)
 767   1          {
 768   2            case FP_BLUE:
 769   2              AS608_SendData(0x01);
 770   2              AS608_SendData(0x01);
 771   2              AS608_SendData(0x00);
 772   2              AS608_SendData(0x50);
 773   2              temp = 0x01+0x07+0x41+0x02+0x50;
 774   2              break;
 775   2            case FP_GREEN:
 776   2              AS608_SendData(0x01);
 777   2              AS608_SendData(0x02);
 778   2              AS608_SendData(0x02);
 779   2              AS608_SendData(0);
 780   2              temp = 0x01+0x07+0x41+0x05+0;
 781   2              break;  
 782   2            case FP_RED:
 783   2              AS608_SendData(0x01);
 784   2              AS608_SendData(0x04);
 785   2              AS608_SendData(0x04);
 786   2              AS608_SendData(0);
 787   2              temp = 0x01+0x07+0x41+0x09+0;
 788   2              break;
 789   2            case FP_NONE_COLOR:
 790   2              AS608_SendData(0x04);
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/04/2021 15:15:14 PAGE 14  

 791   2              AS608_SendData(0x00);
 792   2              AS608_SendData(0x00);
 793   2              AS608_SendData(0xC8);
 794   2              temp = 0x01+0x07+0x41+0x04+0xC8;
 795   2              break;
 796   2          }
 797   1          SendCheck(temp);
 798   1      
 799   1          //sure=ReturnFlag(&p);
 800   1          sure = JudgeStr(1000, 0x03);
 801   1      //#endif
 802   1          Light_Color = light_id;
 803   1      
 804   1      //  }
 805   1      }
 806          
 807          FP_COLOR_E FP_Get_Light(void)
 808          {
 809   1        return Light_Color;
 810   1      }
 811          
 812          
 813          unsigned char FP_Get_Start_Flag(void)
 814          {
 815   1        if(UART0_RXLEN>0)
 816   1        {
 817   2          unsigned char i;
 818   2          
 819   2          for (i = 0; i < UART0_RXLEN; i++)
 820   2          {
 821   3            if (UART0_RXBUF[i] == 0x55)
 822   3            {
 823   4              UART0_RXLEN = 0;
 824   4              return 1;
 825   4            }
 826   3          }
 827   2        }
 828   1        return 0;
 829   1      }
 830          //#endif//__PREIPHERAL_FP_LT5X_SUPPORT__
 831          
 832          
 833          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1948    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     25      54
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
